// Nicolas Robert [Nrx]

// The concept of this game is to challenge players to find a solution to a
// given problem within 30 seconds, then compare their results online, similarly
// to the game "Wordz" on iOS. The problem (target and tiles) is generated by a
// PRNG synchronized on all devices, so that all players are proposed the same
// problem at the same time (this can be performed by having client devices call
// the server at startup to synchronize their clock, and eventually set the seed
// of the PRNG). Each client device submits its player's solution to the server
// at the end of the game session; the server validates each proposition and
// eventually records it into a list if correct (note that the server validates
// the solution against the problem generated on server side using the same game
// number and the exact same PRNG implementation). While players' solutions are
// submitted to the server, clients display the best solution, as provided
// locally by NumbersSolve. Eventually, client devices query the server to get
// the list of solutions, which they sort and/or filter to display the
// leaderboard. A trick is that each client checks whether its own data are
// indeed present in the list, and inserts them locally if needed (so that it is
// possible to discard cheaters on server side, without cheaters to know about
// it - this also deals with clients which would have failed to submit their
// solution for some reasons). Note that it is possible to insert fake players
// (bots), either on server or client side, to fill in the leaderboard when
// there aren't enough players online: NumbersSolve can be used to generate
// plausible solutions with various complexities, simulating players with
// different skills (to look even more realistic, bots could have specific
// profiles, e.g. player names and time slots during which these players could
// appear every day).

// C libraries
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <netdb.h>

// Numbers library
#include "NumbersLibrary.h"

// Random library
#include "RandomLibrary.h"

// Macro to get the number of elements in an array
#define COUNT_OF(array) (sizeof (array) / sizeof ((array)[0]))

// Stringization macros
#define _STRING(str) #str
#define STRING(str) _STRING(str)

// Default server port
#define DEFAULT_PORT 6666

// Maximum number of pending client connections in the queue
#define CLIENT_CONNECTION_COUNT 5

// Count of tiles
#define TILE_COUNT 6

// Maximum length of players' names
#define PLAYER_NAME_LENGTH 20

// Maximum number of leaderboard entries
#define LEADERBOARD_ENTRY_COUNT 128

// Duration of each game state
#define DURATION_STATE_PLAY 30
#define DURATION_STATE_SOLUTION 10
#define DURATION_STATE_LEADERBOARD 10

// FNV-1a hash parameters
#define FNV_OFFSET_BASIS 0x811c9dc5
#define FNV_32_PRIME 0x01000193

// Encoding XOR value
#define ENCODE_XOR_BASIS 85
#define ENCODE_XOR_INCREMENT 7

// Client request types
typedef enum {
    REQUEST_GET_TIME,
    REQUEST_RECORD_SOLUTION,
    REQUEST_GET_LEADERBOARD
} RequestType;

// Player's data
typedef struct {
    uint32_t gameNumber;
    uint32_t uniqueId;
    char name[PLAYER_NAME_LENGTH];
    uint8_t solutionOperations[TILE_COUNT];
    uint8_t solutionTiming;
    int8_t bonusPoints;
} PlayerData;

// Encoded player's data
typedef struct {
    PlayerData data;
    uint32_t hash;
} PlayerDataEncoded;

// Leaderboard entry
typedef struct {
    uint32_t uniqueId;
    char name[PLAYER_NAME_LENGTH];
    uint16_t solutionResult;
    uint8_t solutionTiming;
    int8_t bonusPoints;
    uint32_t hostHash;
} LeaderboardEntry;

// Display the usage
static void DisplayUsage (char* name) {
    printf ("Usage:\n"
        "%s -server [<port>]\n"
        "%s -client <player name> [<server> [<port>]]\n"
        "%s -offline\n",
        name, name, name);
}

// Display an error message
static void DisplayError (char* error) {
    printf ("\nError: %s\n", error);
}

// Display a "sorry" message
static void DisplaySorry (void) {
    puts ("(Sorry, this is not implemented in this demo!)");
}

// Create a problem (i.e. define the list of tiles and target)
static uint32_t ProblemCreate (RandomObject randomObject, uint32_t gameNumber, NumbersTiles* tiles_) {

    // Initialize the PRNG
    RandomSetSeed (randomObject, gameNumber);

    // Define the set of tiles
    uint32_t tileSet[] = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 25, 50, 75, 100};
    NumbersTiles tiles = {COUNT_OF (tileSet), tileSet};
    NumbersShuffle (&tiles, randomObject);
    for (uint32_t tileId = 0; tileId < tiles_->count; ++tileId) {
        tiles_->values[tileId] = tiles.values[tileId];
    }

    // Define the target
    return 101 + (RandomGetValue (randomObject) % 899);
}

// Compare 2 leaderboard entries
static uint32_t LeaderboardEntryIsBetterThan (LeaderboardEntry* a, LeaderboardEntry* b, uint32_t target) {

    // First, compare the absolute value of the difference between the result
    // and the target
    uint32_t errorA = a->solutionResult > target ? a->solutionResult - target : target - a->solutionResult;
    uint32_t errorB = b->solutionResult > target ? b->solutionResult - target : target - b->solutionResult;
    if (errorA < errorB) {
        return 1;
    }
    if (errorA > errorB) {
        return 0;
    }

    // Then, compare the number of bonus points
    if (a->bonusPoints > b->bonusPoints) {
        return 1;
    }
    if (a->bonusPoints < b->bonusPoints) {
        return 0;
    }

    // Finally, compare the time at which the solution was found
    if (a->solutionTiming < b->solutionTiming) {
        return 1;
    }
    return 0;
}

// Encode the player's data before sending the structure from the client to the
// server, to obfuscate a bit what is being transmitted (in particular,
// "solutionTiming" and "bonusPoints" need to be protected, to prevent cheating)
// This function is inlined to make reverse engineering slightly harder...
inline static void EncodePlayerData (const PlayerData* playerData, PlayerDataEncoded* playerDataEncoded) {

    // Compute the FNV-1a hash of the player's data while applying an XOR on
    // each of its byte
    const uint8_t* in = (const uint8_t*)playerData;
    uint8_t* out = (uint8_t*)playerDataEncoded;
    uint8_t xor = ENCODE_XOR_BASIS;
    uint32_t hash = FNV_OFFSET_BASIS;
    for (uint32_t byte = 0; byte < sizeof (*playerData); ++byte) {
        hash ^= in[byte];
        hash *= FNV_32_PRIME;
        out[byte] = in[byte] ^ xor;
        xor += ENCODE_XOR_INCREMENT;
    }
    playerDataEncoded->hash = hash;
}

// Decode the player's data
static uint32_t DecodePlayerData (const PlayerDataEncoded* playerDataEncoded, PlayerData* playerData) {

    // Apply an XOR on each byte of the player's data while computing its FNV-1a
    // hash
    const uint8_t* in = (const uint8_t*)playerDataEncoded;
    uint8_t* out = (uint8_t*)playerData;
    uint8_t xor = ENCODE_XOR_BASIS;
    uint32_t hash = FNV_OFFSET_BASIS;
    for (uint32_t byte = 0; byte < sizeof (*playerData); ++byte) {
        out[byte] = in[byte] ^ xor;
        xor += ENCODE_XOR_INCREMENT;
        hash ^= out[byte];
        hash *= FNV_32_PRIME;
    }

    // Check whether the hash is correct
    return hash == playerDataEncoded->hash;
}

// Server
// Note: To make sure that clients can communicate properly with the server, we
// should handle possible endianness differences (typically, use "ntoh*" and
// "hton*" functions to convert values between host and network byte order when
// sending and receiving messages). We may also opt to use HTTP as the sole
// communication channel. Anyway, we keep things simple for this demo...
static void Server (struct addrinfo* addressInfo) {

    // Open a socket
    int socketDescriptor = -1;
    struct addrinfo* addressInfoCurrent = addressInfo;
    while (addressInfoCurrent) {
        socketDescriptor = socket (addressInfoCurrent->ai_family, addressInfoCurrent->ai_socktype, addressInfoCurrent->ai_protocol);
        if (socketDescriptor < 0) {
            continue;
        }
        if (bind (socketDescriptor, addressInfoCurrent->ai_addr, addressInfoCurrent->ai_addrlen) == 0) {
            break;
        }
        close (socketDescriptor);
        addressInfoCurrent = addressInfoCurrent->ai_next;
    }
    if (!addressInfoCurrent) {
        DisplayError ("Could not open a socket.");
        return;
    }

    // Listen for client connections
    if ((listen (socketDescriptor, CLIENT_CONNECTION_COUNT)) < 0) {
        DisplayError ("Could not listen for client connections.");
        return;
    }

    // Initialize the PRNG
    RandomObject randomObject = RandomInitialize ();

    // Current problem
    uint32_t gameNumberServer = 0;
    uint32_t tileValues[TILE_COUNT] = {0};
    NumbersTiles tiles = {COUNT_OF (tileValues), tileValues};
    uint32_t target = 0;

    // Leaderboard
    // Note: We should eventually use a more appropriate data structure to store
    // leaderboard entries, allowing to quickly check for existing entries or
    // sort the whole list - we may actually opt to have the server keep the
    // list always sorted, so that clients would not need to worry about it
    // (a client would just need to _filter_ the list received from the server
    // when the player wants to see opponents on the same network only, or her
    // registered friends). Anyway, let's keep it simple for this demo...
    LeaderboardEntry leaderboardEntries[LEADERBOARD_ENTRY_COUNT];
    uint32_t leaderboardEntryRecordId = 0;

    // Main loop
    puts ("Server started.");
    while (1) {

        // Accept the client connection
        struct sockaddr_storage clientAddress;
        socklen_t clientAddressLength = sizeof (clientAddress);
        int clientSocketDescriptor = accept (socketDescriptor, (struct sockaddr*)&clientAddress, &clientAddressLength);
        if (clientSocketDescriptor < 0) {
            DisplayError ("Could not accept a client connection.");
            break;
        }

        // Identify the client
        char host[NI_MAXHOST];
        int error = getnameinfo ((struct sockaddr*)&clientAddress, clientAddressLength, host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
        if (error) {
            DisplayError ("Could not identify a client.");
            close (clientSocketDescriptor);
            continue;
        }

        // Receive the client request type
        uint8_t requestType;
        ssize_t byteCount = recv (clientSocketDescriptor, &requestType, sizeof (requestType), MSG_WAITALL);
        if (byteCount != sizeof (requestType)) {
            DisplayError ("Could not receive a client request.");
            close (clientSocketDescriptor);
            continue;
        }

        // Get the server time
        uint32_t serverTime = time (NULL);

        // Compute the FNV-1a hash of the host (this will allow clients to
        // filter the leaderboard and only display players who are on the same
        // network)
        uint32_t hostHash = FNV_OFFSET_BASIS;
        for (uint8_t* byte = (uint8_t*)host; *byte; ++byte) {
            hostHash ^= *byte;
            hostHash *= FNV_32_PRIME;
        }

        // Process the client request
        void* responseData = NULL;
        size_t responseSize = 0;
        switch (requestType) {
            case REQUEST_GET_TIME: {

                // Show the request
                printf ("Got a time request from host #%08x (\"%s\").\n", hostHash, host);

                // Set the response
                responseData = &serverTime;
                responseSize = sizeof (serverTime);
                break;
            }

            case REQUEST_RECORD_SOLUTION: {

                // Receive the player's data
                PlayerDataEncoded playerDataEncoded;
                byteCount = recv (clientSocketDescriptor, &playerDataEncoded, sizeof (playerDataEncoded), MSG_WAITALL);
                if (byteCount != sizeof (playerDataEncoded)) {
                    DisplayError ("Could not receive a player's data.");
                    break;
                }

                // Decode the player's data
                PlayerData playerData;
                if (!DecodePlayerData (&playerDataEncoded, &playerData)) {
                    break;
                }

                // Check the game number
                uint32_t gameNumberCurrent = serverTime / (DURATION_STATE_PLAY + DURATION_STATE_SOLUTION + DURATION_STATE_LEADERBOARD);
                if (playerData.gameNumber != gameNumberCurrent) {
                    break;
                }

                // Set the response
                responseData = &hostHash;
                responseSize = sizeof (hostHash);

                // Update the server data if needed
                if (gameNumberServer != gameNumberCurrent) {
                    gameNumberServer = gameNumberCurrent;

                    // Create the problem
                    target = ProblemCreate (randomObject, gameNumberServer, &tiles);

                    // Clear the leaderboard
                    leaderboardEntryRecordId = 0;
                }

                // Validate the solution
                uint32_t playerResult;
                NumbersError error = NumbersValidate (target, &tiles, playerData.solutionOperations, &playerResult, NULL);
                if (error != Success) {
                    break;
                }

                // Show the request
                printf ("Got a solution from host #%08x (\"%s\"), player #%08x (\"%s\"): result=%u (error=%u), bonus=%hhd, time=%hhd\n",
                    hostHash,
                    host,
                    playerData.uniqueId,
                    playerData.name,
                    playerResult,
                    playerResult > target ? playerResult - target : target - playerResult,
                    playerData.bonusPoints,
                    playerData.solutionTiming);

                // Check whether this player has already recorded a solution in
                // the current list; if so, then just update the corresponding
                // entry, or else record the solution as a new entry
                // Notes:
                // - If the leaderboard is full, then we should discard the
                //   worst entry;
                // - We may provide a way to monitor what name is associated to
                //   each uniqueId, and set a list of "bad players" which the
                //   name should not appear as-is in the leaderboard...
                // ...but this is just a demo, so let's keep things simple
                for (uint32_t leaderboardEntryId = 0; leaderboardEntryId < COUNT_OF (leaderboardEntries); ++leaderboardEntryId) {
                    LeaderboardEntry* leaderboardEntry = &leaderboardEntries[leaderboardEntryId];
                    if (leaderboardEntryId == leaderboardEntryRecordId) {

                        // Record this solution as a new entry
                        leaderboardEntry->uniqueId = playerData.uniqueId;
                        ++leaderboardEntryRecordId;
                    } else if (leaderboardEntry->uniqueId != playerData.uniqueId) {

                        // Check the next entry...
                        continue;
                    }

                    // Record the player's data
                    strncpy (leaderboardEntry->name, playerData.name, sizeof (leaderboardEntry->name) - 1);
                    leaderboardEntry->name[sizeof (leaderboardEntry->name) - 1] = '\0';
                    leaderboardEntry->solutionResult = playerResult;
                    leaderboardEntry->solutionTiming = playerData.solutionTiming;
                    leaderboardEntry->bonusPoints = playerData.bonusPoints;
                    leaderboardEntry->hostHash = hostHash;
                    break;
                }

                // Done
                break;
            }

            case REQUEST_GET_LEADERBOARD: {

                // Receive the player's game number
                uint32_t gameNumberPlayer;
                byteCount = recv (clientSocketDescriptor, &gameNumberPlayer, sizeof (gameNumberPlayer), MSG_WAITALL);
                if (byteCount != sizeof (gameNumberPlayer)) {
                    DisplayError ("Could not receive a player's data.");
                    break;
                }

                // Check the game number
                if (gameNumberPlayer != gameNumberServer) {
                    break;
                }

                // Show the request
                printf ("Got a leaderboard request from host #%08x (\"%s\").\n", hostHash, host);

                // Set the response
                responseData = leaderboardEntries;
                responseSize = leaderboardEntryRecordId * sizeof (leaderboardEntries[0]);
                break;
            }
        }

        // Send the response size
        byteCount = send (clientSocketDescriptor, &responseSize, sizeof (responseSize), MSG_WAITALL);
        if (byteCount != sizeof (responseSize)) {
            DisplayError ("Could not send a response to the client.");
        } else {

            // Send the response data
            byteCount = send (clientSocketDescriptor, responseData, responseSize, MSG_WAITALL);
            if (byteCount != responseSize) {
                DisplayError ("Could not send a response to the client.");
            }
        }

        // Close the client connection
        close (clientSocketDescriptor);
    }

    // Shut down the PRNG
    RandomShutdown (randomObject);

    // Close the socket
    close (socketDescriptor);
}

// Send a request to the server
static ssize_t SendRequest (struct addrinfo* addressInfo, uint8_t requestType,
    void* requestData, size_t requestSize,
    void* responseData, size_t responseSizeMax) {

    // Open a socket
    int socketDescriptor = -1;
    struct addrinfo* addressInfoCurrent = addressInfo;
    while (addressInfoCurrent) {
        socketDescriptor = socket (addressInfoCurrent->ai_family, addressInfoCurrent->ai_socktype, addressInfoCurrent->ai_protocol);
        if (socketDescriptor < 0) {
            continue;
        }
        if (connect (socketDescriptor, addressInfoCurrent->ai_addr, addressInfoCurrent->ai_addrlen) == 0) {
            break;
        }
        close (socketDescriptor);
        addressInfoCurrent = addressInfoCurrent->ai_next;
    }
    if (!addressInfoCurrent) {
        return -1;
    }

    // Send the request type
    ssize_t byteCount = send (socketDescriptor, &requestType, sizeof (requestType), MSG_WAITALL);
    if (byteCount == sizeof (requestType)) {

        // Send the request data
        send (socketDescriptor, requestData, requestSize, MSG_WAITALL);
    }

    // Receive the response size
    ssize_t responseSize = -1;
    byteCount = recv (socketDescriptor, &responseSize, sizeof (responseSize), MSG_WAITALL);
    if (byteCount == sizeof (responseSize)) {

        // Receive the response data
        if (responseSize > responseSizeMax) {
            responseSize = responseSizeMax;
        }
        byteCount = recv (socketDescriptor, responseData, responseSize, MSG_WAITALL);
        if (byteCount != responseSize) {
            responseSize = -1;
        }
    }

    // Close the socket
    close (socketDescriptor);
    return responseSize;
}

// Operation hook
static void OperationHook (NumbersOperation* operation) {
    printf ("  %u %c %u = %u\n",
        operation->valueLeft,
        operation->opChar,
        operation->valueRight,
        operation->valueResult);
}

// Client
static void Client (struct addrinfo* addressInfo, char* playerName) {

    // Initialize the solver
    NumbersObject numbersObject = NULL;
    NumbersError error = NumbersInitialize (25000, 15000, &numbersObject);
    if (error != Success) {
        DisplayError ("Could not initialize the solver.");
        return;
    }

    // Game states
    enum {
        STATE_INIT,
        STATE_PLAY,
        STATE_BONUS,
        STATE_SOLUTION,
        STATE_LEADERBOARD
    } stateCurrent = STATE_INIT, stateNext = STATE_INIT;

    // Game problem
    uint32_t tileValues[TILE_COUNT] = {0};
    NumbersTiles tiles = {COUNT_OF (tileValues), tileValues};
    uint32_t target = 0;

    // Initialize the PRNGs
    RandomObject gameRandom = RandomInitialize ();
    RandomObject playerRandom = RandomInitialize ();

    // Initialize the player's data
    RandomSetSeed (playerRandom, time (NULL));
    PlayerData playerData;
    playerData.gameNumber = 0;
    playerData.uniqueId = RandomGetValue (playerRandom);
    if (playerName) {
        strncpy (playerData.name, playerName, sizeof (playerData.name) - 1);
        playerData.name[sizeof (playerData.name) - 1] = '\0';
    } else {
        playerData.name[0] = '\0';
    }
    uint32_t playerResult = 0;
    uint32_t playerHostHash = 0;

    // For this demo, the human player is simulated...
    uint16_t playerComplexity = RandomGetValue (playerRandom) % 20;
    uint32_t playerThinkingDuration = UINT32_MAX;

    // Check whether the client is online
    uint32_t gameDuration;
    uint32_t timeError = time (NULL);
    if (addressInfo) {

        // Set the game duration
        gameDuration = DURATION_STATE_PLAY + DURATION_STATE_SOLUTION + DURATION_STATE_LEADERBOARD;

        // Get the time from the server
        uint32_t timeServer;
        ssize_t responseSize = SendRequest (addressInfo, REQUEST_GET_TIME,
            NULL, 0,
            &timeServer, sizeof (timeServer));
        if (responseSize != sizeof (timeServer)) {
            DisplayError ("Could not get the time from the server.");
            timeError = 0;
        } else {
            timeError = ((time (NULL) + timeError) >> 1) - timeServer;
        }
    } else {

        // Set the game duration
        gameDuration = DURATION_STATE_PLAY + DURATION_STATE_SOLUTION;

        // Make sure to start right away
        timeError = timeError % gameDuration;
    }

    // Main loop
    while (1) {

        // Check the game number and timing
        uint32_t gameTiming = time (NULL) - timeError;
        uint32_t gameNumber = gameTiming / gameDuration;
        gameTiming -= gameNumber * gameDuration;

        // Define the game state
        if (gameTiming < DURATION_STATE_PLAY) {
            if (stateNext != STATE_BONUS) {
                stateNext = STATE_PLAY;
            }
        } else if (gameTiming < DURATION_STATE_PLAY + DURATION_STATE_SOLUTION) {
            stateNext = STATE_SOLUTION;
        } else {
            stateNext = STATE_LEADERBOARD;
        }

        // Check for a change of state
        if (stateCurrent != stateNext) {

            // Exit the current state
            switch (stateCurrent) {
                case STATE_INIT: {
                    break;
                }

                case STATE_PLAY: {
                    break;
                }

                case STATE_BONUS: {

                    // Simulate a real player: get some bonus points
                    uint32_t playerBonusDuration = DURATION_STATE_PLAY - playerData.solutionTiming;
                    playerData.bonusPoints = RandomGetValue (playerRandom) % playerBonusDuration - playerBonusDuration / 3;
                    printf ("\nMy bonus: %hhd point%s\n", playerData.bonusPoints, playerData.bonusPoints < -1 || playerData.bonusPoints > 1 ? "s" : "");
                    break;
                }

                case STATE_SOLUTION: {
                    break;
                }

                case STATE_LEADERBOARD: {
                    break;
                }
            }

            // Enter the new state
            stateCurrent = stateNext;
            switch (stateCurrent) {
                case STATE_INIT: {
                    break;
                }

                case STATE_PLAY: {

                    // Reset the player's data
                    playerData.gameNumber = gameNumber;
                    playerData.solutionOperations[0] = 0;
                    playerData.solutionTiming = UINT8_MAX;
                    playerData.bonusPoints = 0;
                    playerResult = 0;

                    // Create the problem
                    target = ProblemCreate (gameRandom, gameNumber, &tiles);

                    // Display the problem
                    printf ("\n"
                        "+----------------+\n"
                        "| Game #%08x |\n"
                        "+----------------+\n"
                        "\n"
                        "Problem\n"
                        "-------\n"
                        "\n"
                        "  >> %u <<\n"
                        "\n ",
                        gameNumber, target);
                    for (uint32_t tileId = 0; tileId < tiles.count; ++tileId) {
                        printf (" [%u]", tiles.values[tileId]);
                    }
                    puts ("\n\nPlease enter your solution:");
                    DisplaySorry ();

                    // Simulate a real player: define the thinking duration
                    uint16_t problemComplexity = UINT16_MAX;
                    NumbersSolve (numbersObject, target, &tiles, &problemComplexity, NULL, NULL);
                    uint32_t playerThinkingDifficulty = (problemComplexity > playerComplexity ? problemComplexity - playerComplexity : 0);
                    playerThinkingDuration = 10 + (RandomGetValue (playerRandom) % (10 + playerThinkingDifficulty));
                    break;
                }

                case STATE_BONUS: {

                    // The player enters the bonus time
                    puts ("\nBonus time\n----------\n");
                    DisplaySorry ();
                    break;
                }

                case STATE_SOLUTION: {

                    // Check the game number
                    if (playerData.gameNumber != gameNumber) {
                        puts ("\nWaiting for the current game to end...");
                        break;
                    }

                    // Check whether the client is online
                    if (addressInfo) {

                        // Encode the player's data
                        PlayerDataEncoded playerDataEncoded;
                        EncodePlayerData (&playerData, &playerDataEncoded);

                        // Send the encoded player's data to the server
                        ssize_t responseSize = SendRequest (addressInfo, REQUEST_RECORD_SOLUTION,
                            &playerDataEncoded, sizeof (playerDataEncoded),
                            &playerHostHash, sizeof (playerHostHash));
                        if (responseSize != sizeof (playerHostHash)) {
                            DisplayError ("Could not send the solution to the server.");
                        }
                    }

                    // Solve the problem
                    uint8_t solutionOperations[tiles.count];
                    NumbersError error = NumbersSolve (numbersObject, target, &tiles, NULL, solutionOperations, NULL);
                    if (error == Success || error == AbortedError) {

                        // Show the list of operations
                        puts ("\nBest solution\n-------------\n");
                        uint32_t bestResult;
                        NumbersValidate (target, &tiles, solutionOperations, &bestResult, OperationHook);
                        printf ("\n  >> %u <<\n", bestResult);
                    }
                    break;
                }

                case STATE_LEADERBOARD: {

                    // Check the game number and make sure the client is online
                    if (playerData.gameNumber != gameNumber || !addressInfo) {
                        puts ("");
                        uint32_t nextGameTiming = gameDuration - gameTiming;
                        if (nextGameTiming >= 3) {
                            printf ("Next game in %u seconds... ", nextGameTiming);
                        }
                        puts ("Get ready!");
                        break;
                    }
                    puts ("\nLeaderboard\n-----------");

                    // Get the list of solutions from the server
                    LeaderboardEntry leaderboardEntries[LEADERBOARD_ENTRY_COUNT];
                    ssize_t responseSize = SendRequest (addressInfo, REQUEST_GET_LEADERBOARD,
                        &playerData, sizeof (playerData.gameNumber),
                        leaderboardEntries, sizeof (leaderboardEntries));
                    uint32_t leaderboardEntryCount = responseSize / sizeof (leaderboardEntries[0]);
                    if (leaderboardEntryCount * sizeof (leaderboardEntries[0]) != responseSize) {
                        DisplayError ("Could not get the leaderboard data.");
                        break;
                    }

                    // Check whether the player's solution is in the list, and
                    // insert it if it is absent
                    uint32_t leaderboardEntryId;
                    for (leaderboardEntryId = 0; leaderboardEntryId < leaderboardEntryCount; ++leaderboardEntryId) {
                        if (leaderboardEntries[leaderboardEntryId].uniqueId == playerData.uniqueId) {
                            break;
                        }
                    }
                    if (leaderboardEntryId == leaderboardEntryCount) {

                        // Check whether the leaderboard is full
                        // Note: In case the leaderboard is full, we should
                        // discard the worst entry... but this is just a demo,
                        // so let's keep things simple
                        if (leaderboardEntryCount >= COUNT_OF (leaderboardEntries)) {
                            leaderboardEntryCount = COUNT_OF (leaderboardEntries) - 1;
                        }

                        // Record the player's solution
                        LeaderboardEntry* leaderboardEntry = &leaderboardEntries[leaderboardEntryCount];
                        leaderboardEntry->uniqueId = playerData.uniqueId;
                        strncpy (leaderboardEntry->name, playerData.name, sizeof (leaderboardEntry->name) - 1);
                        leaderboardEntry->name[sizeof (leaderboardEntry->name) - 1] = '\0';
                        leaderboardEntry->solutionResult = playerResult;
                        leaderboardEntry->solutionTiming = playerData.solutionTiming;
                        leaderboardEntry->bonusPoints = playerData.bonusPoints;
                        leaderboardEntry->hostHash = playerHostHash;
                        ++leaderboardEntryCount;
                    }

                    // Insert fake solutions ("bot players") if there are not
                    // enough entries in the leaderboard (make sure to use the
                    // same PRNG seed on all devices so that these bots are the
                    // same for everyone)
                    uint16_t problemComplexity = UINT16_MAX;
                    NumbersSolve (numbersObject, target, &tiles, &problemComplexity, NULL, NULL);

                    RandomSetSeed (gameRandom, gameNumber);
                    struct {
                        char* name;
                        uint16_t complexity;
                    } bots[] = {
                        {"Mochi", 30},
                        {"Azuki", 10},
                        {"Olympe", 5},
                        {"Lucifer", 1}
                    };
                    for (uint32_t botId = 0; botId < COUNT_OF (bots); ++botId) {

                        // Check whether the leaderboard is full
                        if (leaderboardEntryCount >= COUNT_OF (leaderboardEntries)) {
                            break;
                        }

                        // Simulate a real player: the bot solves the problem
                        LeaderboardEntry* leaderboardEntry = &leaderboardEntries[leaderboardEntryCount];
                        uint32_t botResult;
                        uint16_t botComplexity = bots[botId].complexity;
                        uint32_t botThinkingDifficulty = (problemComplexity > botComplexity ? problemComplexity - botComplexity : 0);
                        uint32_t botThinkingDuration = 10 + (RandomGetValue (gameRandom) % (10 + botThinkingDifficulty));
                        if (botThinkingDuration < DURATION_STATE_PLAY) {
                            NumbersError error = NumbersSolve (numbersObject, target, &tiles, &botComplexity, NULL, &botResult);
                            if (error != Success && error != AbortedError) {
                                continue;
                            }
                            uint32_t botBonusDuration = DURATION_STATE_PLAY - botThinkingDuration;
                            leaderboardEntry->solutionTiming = botThinkingDuration;
                            leaderboardEntry->bonusPoints = RandomGetValue (gameRandom) % botBonusDuration - botBonusDuration / 3;
                        } else {
                            NumbersError error = NumbersValidate (target, &tiles, NULL, &botResult, NULL);
                            if (error != Success) {
                                continue;
                            }
                            leaderboardEntry->solutionTiming = UINT8_MAX;
                            leaderboardEntry->bonusPoints = 0;
                        }
                        leaderboardEntry->uniqueId = UINT32_MAX;
                        strncpy (leaderboardEntry->name, bots[botId].name, sizeof (leaderboardEntry->name) - 1);
                        leaderboardEntry->name[sizeof (leaderboardEntry->name) - 1] = '\0';
                        leaderboardEntry->solutionResult = botResult;
                        leaderboardEntry->hostHash = UINT32_MAX;
                        ++leaderboardEntryCount;
                    }

                    // Prepare to sort the leaderboard (insert all the entries
                    // in a heap)
                    uint32_t heap[leaderboardEntryCount];
                    for (uint32_t leaderboardEntryId = 0; leaderboardEntryId < leaderboardEntryCount; ++leaderboardEntryId) {
                        LeaderboardEntry* leaderboardEntry = &leaderboardEntries[leaderboardEntryId];
                        uint32_t heapId = leaderboardEntryId;
                        while (heapId) {
                            uint32_t heapParentId = (heapId - 1) >> 1;
                            LeaderboardEntry* leaderboardEntryParent = &leaderboardEntries[heap[heapParentId]];
                            if (LeaderboardEntryIsBetterThan (leaderboardEntryParent, leaderboardEntry, target)) {
                                break;
                            }
                            heap[heapId] = heap[heapParentId];
                            heapId = heapParentId;
                        }
                        heap[heapId] = leaderboardEntryId;
                    }

                    // Display the sorted leaderboard
                    // Note: We may also filter the entries...
                    printf ("\n  | %-*s| Result | Error | Bonus | Time | Network   | Player ID |\n",
                        (int)sizeof (leaderboardEntries[0].name),
                        "Player name");
                    uint32_t heapLastId = leaderboardEntryCount;
                    for (leaderboardEntryId = 0; leaderboardEntryId < leaderboardEntryCount; ++leaderboardEntryId) {

                        // Display the best entry
                        uint32_t heapId = 0;
                        LeaderboardEntry* leaderboardEntry = &leaderboardEntries[heap[heapId]];
                        printf ("  | %-*s| %6hu | %5u | %5hhd | %4hhd | #%08x | #%08x |\n",
                            (int)sizeof (leaderboardEntry->name),
                            leaderboardEntry->name,
                            leaderboardEntry->solutionResult,
                            leaderboardEntry->solutionResult > target ? leaderboardEntry->solutionResult - target : target - leaderboardEntry->solutionResult,
                            leaderboardEntry->bonusPoints,
                            leaderboardEntry->solutionTiming,
                            leaderboardEntry->hostHash,
                            leaderboardEntry->uniqueId);

                        // Update the heap
                        --heapLastId;
                        LeaderboardEntry* leaderboardEntryLast = &leaderboardEntries[heap[heapLastId]];
                        uint32_t heapChildId;
                        while ((heapChildId = (heapId << 1) + 1) < heapLastId) {
                            LeaderboardEntry* leaderboardEntryLeft = &leaderboardEntries[heap[heapChildId]];
                            LeaderboardEntry* leaderboardEntryRight = &leaderboardEntries[heap[heapChildId + 1]];
                            if (LeaderboardEntryIsBetterThan (leaderboardEntryLeft, leaderboardEntryRight, target)) {
                                if (LeaderboardEntryIsBetterThan (leaderboardEntryLast, leaderboardEntryLeft, target)) {
                                    break;
                                }
                            } else {
                                if (LeaderboardEntryIsBetterThan (leaderboardEntryLast, leaderboardEntryRight, target)) {
                                    break;
                                }
                                ++heapChildId;
                            }
                            heap[heapId] = heap[heapChildId];
                            heapId = heapChildId;
                        }
                        heap[heapId] = heap[heapLastId];
                    }
                    break;
                }
            }
        }

        // Handle the state machine
        switch (stateCurrent) {
            case STATE_INIT: {
                break;
            }

            case STATE_PLAY: {

                // The human player can input her solution, selecting tiles and
                // operations... In this demo, we just simulate it
                if (gameTiming >= playerThinkingDuration) {

                    // Simulate a real player: solve the problem
                    uint16_t complexity = playerComplexity;
                    NumbersSolve (numbersObject, target, &tiles, &complexity, playerData.solutionOperations, &playerResult);
                    playerData.solutionTiming = gameTiming;
                    printf ("\nMy result: %u\n", playerResult);

                    // Enter the bonus state
                    stateNext = STATE_BONUS;
                }
                break;
            }

            case STATE_BONUS: {

                // During the bonus state, the player is proposed little math
                // challenges that eventually allow her to alter her final
                // ranking. A bonus challenge is a math operation of the form
                // "A x B + C = D" in which one number is missing, and a list of
                // 3 numbers from which the player must select one; the player
                // only has 3 seconds to make her choice, before another bonus
                // challenge is proposed (and until the game ends). The player
                // is awarded 1 "bonus point" for every correct answer, but she
                // loses 1 bonus point for every wrong answer; her total number
                // of bonus points is sent to the server along with her
                // solution, and recorded into the server list. This allows
                // clients to sort the list according to players' results first
                // (or to say, according to the absolute value of the difference
                // between the result and the target), then according to their
                // number of bonus points, and then according to the time at
                // which the solution was found.
                // The bonus state is not implemented in this demo...
                break;
            }

            case STATE_SOLUTION: {
                break;
            }

            case STATE_LEADERBOARD: {
                break;
            }
        }

        // Be nice to the system
        sleep (1);
    }

    // Shut down the PRNGs
    RandomShutdown (playerRandom);
    RandomShutdown (gameRandom);

    // Shut down the solver
    NumbersShutdown (numbersObject);
}

// Main
int main (int argc, char** argv) {

    // Check the arguments
    const char* node = NULL;
    const char* service = NULL;
    if (argc >= 2) {
        if (!strcmp (argv[1], "-server")) {
            if (argc == 2) {
                service = STRING (DEFAULT_PORT);
            } else if (argc == 3) {
                service = argv[2];
            }
        } else if (!strcmp (argv[1], "-client")) {
            if (argc == 3) {
                node = "localhost";
                service = STRING (DEFAULT_PORT);
            } else if (argc == 4) {
                node = argv[3];
                service = STRING (DEFAULT_PORT);
            } else if (argc == 5) {
                node = argv[3];
                service = argv[4];
            }
        } else if (argc == 2 && !strcmp (argv[1], "-offline")) {
            node = argv[1];
        }
    }
    if (!service && !node) {
        DisplayUsage (argv[0]);
        return -1;
    }

    // Get the address information
    struct addrinfo* addressInfo = NULL;
    if (service) {
        struct addrinfo addressHints = {node ? 0 : AI_PASSIVE, AF_UNSPEC, SOCK_STREAM, 0, 0, NULL, NULL, NULL};
        if (getaddrinfo (node, service, &addressHints, &addressInfo) != 0) {
            DisplayError ("Could not get the address information.");
            return -1;
        }
    }

    // Launch the server or the client
    if (!addressInfo) {
        Client (NULL, NULL);
    } else if (!node) {
        Server (addressInfo);
    } else {
        Client (addressInfo, argv[2]);
    }

    // Done
    if (addressInfo) {
        freeaddrinfo (addressInfo);
    }
    return 0;
}
